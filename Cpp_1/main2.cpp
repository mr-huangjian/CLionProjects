//
// Created by huangjian on 7/29/21.
//

#include <iostream>
#include <string>

using namespace std; // 使用 std 命名空间

/**
 * 类型限定符:
 * const 类型的对象在程序执行期间不能被修改改变。
 * volatile	修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。
 *          对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。
 * restrict	由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。
 */

/**
 * 存储类修饰符
 * auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。
 * register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。
 *          这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
 *          寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，
 *          它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。
 * static   存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
 *          因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
 *          static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
 *          在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
 * extern   存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
 *          当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。
 * thread_local 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。
 *              变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。
 *              thread_local 说明符可以与 static 或 extern 合并。
 *              可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。
 */

/*
int main() {
    string message = "Hello";
    const int count = 0;

    cout << "message: " << message << ", count: " << count << endl;

    return 0;
}
*/
